(define <id> <expression>)

(define pi 3.14)


(define (<id>     <id>*) <expression>+)
	      param.lista

> (define (foo a)(substring a 0 3))
> (foo "abrakaadda")
"abr"

REPL
#t true
#f false
() {} [] ",'`;#\| nem haszn. azonosítóként

függvény hívás:
(<id> <expr>*)

> (substring "Hódmezőhelyvásár" 0 5)
"Hódme"
> (string-append "Hód" "Mező" "hely")
"HódMezőhely"
> (string-length "mezőhelyhód")
11
> (string? "mezőhódvásár")
#t 
> (sqrt -16)
0+4i
> (+ 25 6 23 1 67 7 8 2 9)
148
> (- 2 44)
-42
> (> 5 2)
#t
> (< 5 2)
#f
> (number? "asd")
#f
> (= 5 2)
#f
> (equal? "macska" 2012)
#f

(if <expr> <expr> <expr>)
 ha nem hamis-akkor a 2-dik, ha hamis akkor a 3-dik expr

> (if (> 3 2) "nagyobb" "kisebb")
"nagyobb"
> (if 1 "egy" "nem egy")
"egy"
> (if -1 "minusz" "plusz")
"minusz"
> (define (reply s)
    (if (equal? "hello" (substring s 0 5))
        "hi!"
        "nem hi"))
> (reply "hello")
"hi!"
> (reply "welcome ")
"nem hi"
> (reply 12345)
. . substring: contract violation
  expected: string?
  given: 12345
  argument position: 1st
  other arguments...:
> (reply "asd")
. . substring: ending index is out of range
  ending index: 5
  starting index: 0
  valid range: [0, 3]
  string: "asd"
(and <expr>*)  ha a paraméterek közül hamis valamelyik, akkor hamis, egyébként az utolsó paraméter
(or <expr>*) ha igaz, akkor az első igaz értéket adja vissza, egyébként hamis
> (and)
#t
> (or)
#f

(define (reply s)
  (if (string? s)
      (if (>= (string-length s) 5)
          (if (equal? "hello" (substring s 0 5))
                          "hi"
                          "huh?")
          "huh?")
        "huh?")
      )

(define (reply s)
  (if(and(string? s )(>= (string-length s) 5)
          (equal? "hello" (substring s 0 5))
                         )
           "hi"
           "huh?")
        )

f1=0
f2=1
fn=fn-1 +fn-2 ha n>2

(define (fibo n)
  (if(> n 2) 
     (+ (fibo (- n 1)) (fibo (- n 2)))
     1)
)
(require racket/trace)
(trace fibo)
(fibo 12)
kommentelés |# 
#|(fibo 12)|#

(define my-fact(lambda (x)
		(if (= x 0)
		1
		(* x (my-fact (- x 1)))
		)
		)
)

(define mypow
  (lambda (base exp)
  (if (= 0 exp)
      1
      (* base (mypow base (- exp 1))))))








(- 4 (+ 1 1))
      redex    =reducible expression- redukálható kifejezés

continuation =minden, ami a redex után van

tail position:

expr1 farok pozícióban van expr2-re nézve, ha valahányszor expr1 egy redex, akkor az ő continuation-je azonos az expr2 continuation-jével.


C[(+ 1 1)] = C[(-4 [])]
C[(- 4 [])]= C

(if (zero? 0) (+ 1 1) 3)
C[(if (zero? 0) (+ 1 1) 3)] = C[(if #t (+ 1 1) 3)] = C[(+ 1 1)]


faktoriális farok pozicióval:

(define f
  (lambda (n prod)
   (if (= 0 n)
    prod
    (f (- n 1) (* n prod))
   )
  )
 )



(let binds body)
binds: ((vl expr) (v2 expr)...)

(let ((i 2) (j 3))
  (+ i j))

5

(let ((i 2))
  (let ((j (+ i 2)))
    (* i j)))

8

(let ((+ *) (* +))
  (+ (* 3 4) (* 2 5)))

49

(let ((+ *))
	(let ((* +))
 	(+ (* 3 4) (* 2 5))))

120

(let* ((i 2) (j (+ i 2)))
(+ i j))

6


(let ((p1 v1) (p2 v2) ...) expr1 expr2 ...) egyenértékű:
((lambda (p1 p2 ...) expr1 expr2 ...) v1 v2 ...)

#|másodfokú egyenlet megoldó függvény -b +- (/ (sqrt(- (* b b) (* (* 4 a) c)))) (* 2 a))|#

(define (quadric a b c)
  
  )




letrec 
(do binds (predicate value) body), ahol
binds= ([p1 i1 u1] [p2 i2 u2] ...)



listák

pair(pár)
car
cdr

list(lista)
vagy üres(null), vagy olyan pár, amelynek a másik tagja egy lista




(pair? 1) 
#f
(pair? (cons 1 2))
#t
(pair? (list 1 2))
#t
(pair? '(1 2))
#t
(pair? '())
#f

(null? 1)
#f
(null? '(2 1))
#f
(null? '())
#t
(null? (cdr (list 1)))
#t      ^^^a végét kérjük le

(displayln "---")

(cons 1 2)
'(1 . 2)

(cons 1 '())
'(1)

(car '(1 2))
1^^^az elejét kérjük le
(car (cons 2 3))
2
(cdr '(1 2))
'(2)
(cdr '(1))
'()

null
'()
(eq? '() null)
#t

(list? '(1 2))
#t
(list? (cons 1(cons 2 '() )))
#t
(list? (cons 1 2))
#f

(list 1 2 3 4)
'(1 2 3 4)
(list (list 1 2) (list 3 4))
'((1 2) (3 4))

   ˇˇˇˇaz utolsó argumentumot berakja faroknak
(list* 1 2)
'(1 . 2)
(list* 1 2 (list 3 4))
'(1 2 3 4)

(build-list 10 values)
'(0 1 2 3 4 5 6 7 8 9)
(build-list 5 (lambda (x) (* x x)))
'(0 1 4 9 16)

(length (list 1 2 3 4))
4
(length '())
0

(list-ref (list 1 2 3 4) 2)
3
(list-ref (list 'a 'b 'c) 0)
'a
(list-ref (list 'a 'b 'c) 1)
'b
(list-ref (list 'a 'b 'c) 2)
'c

(list-ref (cons 1 2) 0)
1
(list-ref (cons 1 2) 1)
index reaches a non-pair
  index: 1
  in: '(1 . 2)


(list-tail (list 1 2 3 4 5) 2)
'(3 4 5)
(list-tail (cons 1 2) 1)
2
(list-tail (cons 1 2) 2)
nem pár, error
(list-tail 'not-a-pair 0)
'not-a-pair

(append (list 1 2) (list 3 4) (list 4 5 6) (list 1 3 2))
'(1 2 3 4 4 5 6 1 3 2)
(reverse (list 1 2 3 4 5))
'(5 4 3 2 1)

(define (my-reverse lst)
(let loop ((lst lst) (new-lst null))
  (cond
    [(null? lst) new-lst]
    [else (loop (cdr lst) (cons (car lst) new-lst))]
  )
)
)

(define (my-reverse2 lst)
(cond
[(null? lst) lst]
[else (append (my-reverse2 (cdr lst)) (list (car lst)))]
)
)

(define (my-length2 lst)
  (define (myl l n)
(cond
  [(null? l) n]
  [else (myl (cdr l) (add1 n))]))
  (myl lst 0))

add1
sub1



(map proc lst...+)
----------------------------
(map (lambda (n) (+ 1 n)) '(1 2 3 4) )

>'(2 3 4 5)


(map (lambda (a b) (+ a b)) '(1 2 3 4) '(10 100 1000 1111))
'(11 102 1003 1115)


(andmap proc lst ...+)
(andmap f (list x y z)) <=> (and (f x) (f y) (f z))
-----------------------------
(andmap positive? '(1 2 3))
#t
(andmap positive? '(1 -2 a))
#f
(andmap positive? '(1 2 a))
positive?: contract violation
  expected: real?
(andmap + '(1 2 3) '( 4 5 6))
9<-- 3+6(utolsó elemek)

(ormap proc lst...+)
(ormap f (list x y z)) <=> (or (f x) (f y) (f z))
------------------------------------------------
(ormap eq? '(a b c) '(a b c))
#t
(ormap positive? '(1 2 a))
#t
(ormap + '(1 2 3) '(4 5 6))
5

(for-each proc lst...+)
----------------------------------
(for-each (lambda (n) (printf "Paraméter ~a\n" n))'(1 2 3 4)) 
Paraméter 1
Paraméter 2
Paraméter 3
Paraméter 4

(foldl proc init lst...+)
(foldr proc init lst...+)
---------------------------------
(foldl cons '() '(1 2 3 4))
'(4 3 2 1)
(foldl + 0 '( 1 2 3 4))
10
(foldl (lambda (a b result) (* result (- a b))) 1 '( 1 2 3 4) '(5 6 7 8))
256

(foldr cons '() '(1 2 3 4))
'(1 2 3 4)
(foldr (lambda (v l) (cons (add1 v) l)) '() '(1 2 3 4))
'(2 3 4 5)

(filter pred lst)
----------------------------------
(filter positive? '( 1 2 -3 5 -2 55 -12))
'(1 2 5 55) a #f eltünik a listából

(remove value lst [proc]) első listaelem eltüntetése, ami egyenlő a value-vel
---------------------------------
(remove 2 (list 1 2 3 4))
'(1 3 4)
(remove 2 (list 1 2 3 2 4) =)
'(1 3 2 4)

(remove 2 (list 1 2 3 2 4) >)
'(2 3 2 4)
(remove 2 (list 1 2 3 2 4) <)
'(1 2 2 4)
(remove '(2) (list '(1) '(2) '(3)))
'((1) (3))
(remove #\c (list #\a #\b #\c))
'(#\a #\b)

(remove* v-lst lst [proc]) az összeset eltávolítja
---------------------------------------
(remove* (list 1 2) (list 1 2 3 4 1 5 2 5 3 2 1 66 764))
'(3 4 5 5 3 66 764)

---------(my-remove value lst)----------------
